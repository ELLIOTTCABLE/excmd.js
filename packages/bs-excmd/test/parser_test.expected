

### Simple, single command:
Parser.expression "test"
{ "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] }

### Single command, with count:
Parser.expression "2test"
{ "count": 2, "cmd": [ "Literal", "test" ], "rev_args": [] }

### Single command, with single positional parameter:
Parser.expression "test foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single command, with single positional URL:
Parser.expression "test google.com/search"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "google.com/search" ] ] ]
}

### Single command, count, and single positional parameter:
Parser.expression "2test foo"
{
  "count": 2,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single command, with multiple positional parameters:
Parser.expression "test foo bar"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Positional", [ "Literal", "foo" ] ]
  ]
}

### Single command, count, and multiple positional parameters:
Parser.expression "2test foo bar"
{
  "count": 2,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Positional", [ "Literal", "foo" ] ]
  ]
}

### Single command, with single boolean flag:
Parser.expression "test --foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Flag", { "name": "foo", "payload": [ "Absent" ] } ] ]
}

### Single command, with multiple boolean flags:
Parser.expression "test --foo --bar"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Flag", { "name": "bar", "payload": [ "Absent" ] } ],
    [ "Flag", { "name": "foo", "payload": [ "Absent" ] } ]
  ]
}

### Single command, with single boolean short-flag:
Parser.expression "test -f"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Flag", { "name": "f", "payload": [ "Absent" ] } ] ]
}

### Single command, with multiple, concatenated boolean short-flags:
Parser.expression "test -foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Flag", { "name": "o", "payload": [ "Absent" ] } ],
    [ "Flag", { "name": "o", "payload": [ "Absent" ] } ],
    [ "Flag", { "name": "f", "payload": [ "Absent" ] } ]
  ]
}

### Single command, with multiple, separated boolean short-flags:
Parser.expression "test -f -o -o"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Flag", { "name": "o", "payload": [ "Absent" ] } ],
    [ "Flag", { "name": "o", "payload": [ "Absent" ] } ],
    [ "Flag", { "name": "f", "payload": [ "Absent" ] } ]
  ]
}

### Single command, with single possibly-parameterized flag:
Parser.expression "test --foo bar"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Single command, with single possibly-parameterized short-flag:
Parser.expression "test -f bar"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "f", "payload": [ "Unresolved" ] } ]
  ]
}

### Single command, single possibly-parameterized short-flag, and a URL:
Parser.expression "test -f google.com/search"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "google.com/search" ] ],
    [ "Flag", { "name": "f", "payload": [ "Unresolved" ] } ]
  ]
}

### Single command with single possibly-parameterized flag followed by a positional parameter:
Parser.expression "test --foo bar baz"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "baz" ] ],
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Single command with two possibly-parameterized flags:
Parser.expression "test --foo bar --baz widget"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "widget" ] ],
    [ "Flag", { "name": "baz", "payload": [ "Unresolved" ] } ],
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Single command, with single explicitly-parameterized flag:
Parser.expression "test --foo=bar"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [
      "Flag",
      { "name": "foo", "payload": [ "Resolved", [ "Literal", "bar" ] ] }
    ]
  ]
}

### Single command with single explicitly-parameterized flag followed by a positional parameter:
Parser.expression "test --foo=bar baz"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "baz" ] ],
    [
      "Flag",
      { "name": "foo", "payload": [ "Resolved", [ "Literal", "bar" ] ] }
    ]
  ]
}

### Single command, single explicitly-parameterized flag with a URL payload, followed by a positional parameter:
Parser.expression "test --foo=google.com/search baz"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "baz" ] ],
    [
      "Flag",
      {
        "name": "foo",
        "payload": [ "Resolved", [ "Literal", "google.com/search" ] ]
      }
    ]
  ]
}

### Single command with a bare-double-dash:
Parser.expression "test --"
{ "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] }

### Single command with a bare-double-dash followed by a long-flag:
Parser.expression "test -- --foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "--foo" ] ] ]
}

### Single command with a bare-double-dash followed by another, normal positional:
Parser.expression "test -- foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single command with mixed flags and parameters:
Parser.expression "test --foo bar --baz=widget qux -qu ux"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "ux" ] ],
    [ "Flag", { "name": "u", "payload": [ "Unresolved" ] } ],
    [ "Flag", { "name": "q", "payload": [ "Absent" ] } ],
    [ "Positional", [ "Literal", "qux" ] ],
    [
      "Flag",
      { "name": "baz", "payload": [ "Resolved", [ "Literal", "widget" ] ] }
    ],
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Single dquoted command:
Parser.expression "\"test\""
{ "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] }

### Single dquoted command with bare positional:
Parser.expression "\"test\" foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single dquoted command with bare flag:
Parser.expression "\"test\" --foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Flag", { "name": "foo", "payload": [ "Absent" ] } ] ]
}

### Bare command with single dquoted positional:
Parser.expression "test \"foo\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single dquoted command with single dquoted positional:
Parser.expression "\"test\" \"foo\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single dquoted command, bare flag, and dquoted payload:
Parser.expression "\"test\" --foo \"bar\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Single dquoted command, flag-esque positional, and positional:
Parser.expression "\"test\" \"--foo\" \"bar\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Positional", [ "Literal", "--foo" ] ]
  ]
}

### Bare command, bare-double-dash, and quoted positional:
Parser.expression "test -- \"foo bar\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo bar" ] ] ]
}

### Bare command, long-flag, flag's name quoted:
Parser.expression "test --\"foo\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Flag", { "name": "foo", "payload": [ "Absent" ] } ] ]
}

### Bare command, long-flag, with a space in the flag's name:
Parser.expression "test --\"foo bar\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Flag", { "name": "foo bar", "payload": [ "Absent" ] } ] ]
}

### Bare command, long-flag w/ space in name, possibly-parameterized:
Parser.expression "test --\"foo bar\" baz"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "baz" ] ],
    [ "Flag", { "name": "foo bar", "payload": [ "Unresolved" ] } ]
  ]
}

### Bare command, long-flag w/ space in name, explicitly-parameterized:
Parser.expression "test --\"foo bar\"=baz"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [
      "Flag",
      { "name": "foo bar", "payload": [ "Resolved", [ "Literal", "baz" ] ] }
    ]
  ]
}

### Bare command, long-flag w/ space in name, explicit, quoted parameter:
Parser.expression "test --\"foo bar\"=\"baz widget\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [
      "Flag",
      {
        "name": "foo bar",
        "payload": [ "Resolved", [ "Literal", "baz widget" ] ]
      }
    ]
  ]
}

### Subexpression in command-position:
Parser.expression "2(echo test)"
{
  "count": 2,
  "cmd": [
    "Sub",
    {
      "count": 1,
      "cmd": [ "Literal", "echo" ],
      "rev_args": [ [ "Positional", [ "Literal", "test" ] ] ]
    }
  ],
  "rev_args": []
}

### Subexpression in command-position with command-quotation:
Parser.expression "2(\"echo test\")"
{
  "count": 2,
  "cmd": [
    "Sub",
    { "count": 1, "cmd": [ "Literal", "echo test" ], "rev_args": [] }
  ],
  "rev_args": []
}

### Subexpression as positional:
Parser.expression "defer (echo test)"
{
  "count": 1,
  "cmd": [ "Literal", "defer" ],
  "rev_args": [
    [
      "Positional",
      [
        "Sub",
        {
          "count": 1,
          "cmd": [ "Literal", "echo" ],
          "rev_args": [ [ "Positional", [ "Literal", "test" ] ] ]
        }
      ]
    ]
  ]
}

### Subexpression as unresolved flag payload:
Parser.expression "defer --foo (echo test)"
{
  "count": 1,
  "cmd": [ "Literal", "defer" ],
  "rev_args": [
    [
      "Positional",
      [
        "Sub",
        {
          "count": 1,
          "cmd": [ "Literal", "echo" ],
          "rev_args": [ [ "Positional", [ "Literal", "test" ] ] ]
        }
      ]
    ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Subexpression as explicit flag payload:
Parser.expression "defer --foo=(echo test)"
{
  "count": 1,
  "cmd": [ "Literal", "defer" ],
  "rev_args": [
    [
      "Flag",
      {
        "name": "foo",
        "payload": [
          "Resolved",
          [
            "Sub",
            {
              "count": 1,
              "cmd": [ "Literal", "echo" ],
              "rev_args": [ [ "Positional", [ "Literal", "test" ] ] ]
            }
          ]
        ]
      }
    ]
  ]
}

### Subexpression-positional after explicit flag payload:
Parser.expression "defer --foo=bar (echo test)"
{
  "count": 1,
  "cmd": [ "Literal", "defer" ],
  "rev_args": [
    [
      "Positional",
      [
        "Sub",
        {
          "count": 1,
          "cmd": [ "Literal", "echo" ],
          "rev_args": [ [ "Positional", [ "Literal", "test" ] ] ]
        }
      ]
    ],
    [
      "Flag",
      { "name": "foo", "payload": [ "Resolved", [ "Literal", "bar" ] ] }
    ]
  ]
}

### Nested subexpressions:
Parser.expression "a ( b (c) d ) e"
{
  "count": 1,
  "cmd": [ "Literal", "a" ],
  "rev_args": [
    [ "Positional", [ "Literal", "e" ] ],
    [
      "Positional",
      [
        "Sub",
        {
          "count": 1,
          "cmd": [ "Literal", "b" ],
          "rev_args": [
            [ "Positional", [ "Literal", "d" ] ],
            [
              "Positional",
              [
                "Sub",
                { "count": 1, "cmd": [ "Literal", "c" ], "rev_args": [] }
              ]
            ]
          ]
        }
      ]
    ]
  ]
}

### Piped command:
Parser.expression "echo test | echo"
{
  "count": 1,
  "cmd": [ "Literal", "echo" ],
  "rev_args": [
    [
      "Positional",
      [
        "Sub",
        {
          "count": 1,
          "cmd": [ "Literal", "echo" ],
          "rev_args": [ [ "Positional", [ "Literal", "test" ] ] ]
        }
      ]
    ]
  ]
}

### Piped command with parenthetical subexpr:
Parser.expression "echo test | (determine_command)"
{
  "count": 1,
  "cmd": [
    "Sub",
    { "count": 1, "cmd": [ "Literal", "determine_command" ], "rev_args": [] }
  ],
  "rev_args": [
    [
      "Positional",
      [
        "Sub",
        {
          "count": 1,
          "cmd": [ "Literal", "echo" ],
          "rev_args": [ [ "Positional", [ "Literal", "test" ] ] ]
        }
      ]
    ]
  ]
}

### Subexpression with piped command:
Parser.expression "foo (bar baz | widget)"
{
  "count": 1,
  "cmd": [ "Literal", "foo" ],
  "rev_args": [
    [
      "Positional",
      [
        "Sub",
        {
          "count": 1,
          "cmd": [ "Literal", "widget" ],
          "rev_args": [
            [
              "Positional",
              [
                "Sub",
                {
                  "count": 1,
                  "cmd": [ "Literal", "bar" ],
                  "rev_args": [ [ "Positional", [ "Literal", "baz" ] ] ]
                }
              ]
            ]
          ]
        }
      ]
    ]
  ]
}

### Complex subexpressions, with flags and quotation:
Parser.expression "defer (2echo -n --sep=\"\\n - \" (bookmark_get \"sommat else\") | do_a_thing)"
{
  "count": 1,
  "cmd": [ "Literal", "defer" ],
  "rev_args": [
    [
      "Positional",
      [
        "Sub",
        {
          "count": 1,
          "cmd": [ "Literal", "do_a_thing" ],
          "rev_args": [
            [
              "Positional",
              [
                "Sub",
                {
                  "count": 2,
                  "cmd": [ "Literal", "echo" ],
                  "rev_args": [
                    [
                      "Positional",
                      [
                        "Sub",
                        {
                          "count": 1,
                          "cmd": [ "Literal", "bookmark_get" ],
                          "rev_args": [
                            [ "Positional", [ "Literal", "sommat else" ] ]
                          ]
                        }
                      ]
                    ],
                    [
                      "Flag",
                      {
                        "name": "sep",
                        "payload": [ "Resolved", [ "Literal", "\n - " ] ]
                      }
                    ],
                    [ "Flag", { "name": "n", "payload": [ "Absent" ] } ]
                  ]
                }
              ]
            ]
          ]
        }
      ]
    ]
  ]
}

### Expressions separated by semicolons:
Parser.script "test; 2test; 3test"
{
  "expressions": [
    { "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 2, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 3, "cmd": [ "Literal", "test" ], "rev_args": [] }
  ]
}

### Expressions separated by semicolons, with a trailing semicolon:
Parser.script "test; 2test; 3test;"
{
  "expressions": [
    { "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 2, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 3, "cmd": [ "Literal", "test" ], "rev_args": [] }
  ]
}

### Expressions, with arguments, separated by semicolons:
Parser.script "test --foo bar; 2test --foo=bar; 3test --foo bar"
{
  "expressions": [
    {
      "count": 1,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [ "Positional", [ "Literal", "bar" ] ],
        [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
      ]
    },
    {
      "count": 2,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [
          "Flag",
          { "name": "foo", "payload": [ "Resolved", [ "Literal", "bar" ] ] }
        ]
      ]
    },
    {
      "count": 3,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [ "Positional", [ "Literal", "bar" ] ],
        [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
      ]
    }
  ]
}

### Expressions, with arguments, separated by semicolons, with a trailing semicolon:
Parser.script "test --foo bar; 2test --foo=bar; 3test --foo bar;"
{
  "expressions": [
    {
      "count": 1,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [ "Positional", [ "Literal", "bar" ] ],
        [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
      ]
    },
    {
      "count": 2,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [
          "Flag",
          { "name": "foo", "payload": [ "Resolved", [ "Literal", "bar" ] ] }
        ]
      ]
    },
    {
      "count": 3,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [ "Positional", [ "Literal", "bar" ] ],
        [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
      ]
    }
  ]
}

### Newlines after expressions:
Parser.script "test;\n   2test;\n   3test"
{
  "expressions": [
    { "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 2, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 3, "cmd": [ "Literal", "test" ], "rev_args": [] }
  ]
}

### Newlines after expressions, with a trailing newline:
Parser.script "test;\n   2test;\n   3test;\n   "
{
  "expressions": [
    { "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 2, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 3, "cmd": [ "Literal", "test" ], "rev_args": [] }
  ]
}

### An acceptable expression, incrementally:
Incremental.expression "hello --where=world"
{
  "count": 1,
  "cmd": [ "Literal", "hello" ],
  "rev_args": [
    [
      "Flag",
      { "name": "where", "payload": [ "Resolved", [ "Literal", "world" ] ] }
    ]
  ]
}

### A failing expression, incrementally:
Incremental.expression "hello --where="
fail-continuation invoked! cool.


### Listing of acceptable tokens during a failure:
Incremental.expression "hello --where="
URL_START, QUOTE_OPEN, PAREN_OPEN, IDENTIFIER


### Dumping of stack-debugging information from a checkpoint:
Incremental.expression "hello --where="
InputNeeded
Terminal
unit
EQUALS
EQUALS : (unit) Terminal
_flag_long : (string) Nonterminal
command : (string AST.or_subexpr) Nonterminal
option_COUNT_ : (string option) Nonterminal
list_COLON_ : (unit list) Nonterminal


### Ascertaining of current command from a checkpoint:
Incremental.expression "a_command_name --blah="
a_command_name
